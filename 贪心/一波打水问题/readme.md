#### 由某一道我出的校赛题想到的

### 1.0
> 一群人排队在一个水龙头打水，i 打水花费时间为 ```ti``` ，每个人都要等前面的人打完才能打水，求所有人的**等待时间和**最短是多少。

很显然，让时间短的人先打。

#### 1.1
> 如果有两个水龙头呢。

还是很显然，每次都让最短的人打，不过这个时候实现的是否优秀呢。

```cpp
//数组模拟版本
#include <bits/stdc++.h>
using namespace std;
int aa[10000];
int pq[2];
int main()
{
    int n;
    scanf("%d",&n);
    int sum = 0;
    for(int i = 0; i < n; i++){
        scanf("%d",&aa[i]);
        sum+=aa[i];
    }
    sort(aa,aa+n);
    int hd = 0;
    bool flag = true;
    int cnt = n;
    while(hd<n){
        pq[0] = aa[hd];
        hd++;cnt--;
        if(cnt==0)break;
        if(flag){
            pq[1] = aa[hd];
            hd++;cnt--;
            flag = false;
        }
        if(pq[0]==pq[1])flag = true;
        else if(pq[0]>pq[1])swap(pq[0],pq[1]);
        sum+=pq[0]*cnt;
        pq[1] -= pq[0];
    }
    printf("%d\n",sum);
    return 0;
}

```

#### 1.2
> 如果有m个水龙头呢


#### 1.3
> 如果，不规定每个人必须打完下一个人才打，一个人可以打好多次才打完呢。

****

### 2.0
> 还是排队打水，两个水龙头，每个人都要等前面的人打完才能打水，不过这个时候只计算**打水花费的时间**，求整体的最短打水时间（不是单独每个人的加起来了）。

很显然，这次的重点是**单独打水的人时间不要太长**，大家尽量有人同时打水。
方法是，贪心的选择最大的两个，去打水。可以证明，这种策略总是最优的。

#### 2.1
> 如果不规定每个人必须打完下一个人才打呢。

准备一个优先队列，次大的结束以后，将最大的减去次大的放回优先队列，然后再送上来两个队头的。
等会证明一下。

#### 2.2
> 如果有 r 个水龙头呢。

同理

待续……